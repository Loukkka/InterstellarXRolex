<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Interstellar X Rolex - VR</title>
	<style>
		body { margin: 0; background: #000; }
		#clock-audio { display: none; }
	</style>
	<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
	<script>
		// === AUDIO HORLOGE: Gestion de la vitesse de lecture ===
		let clockAudio = null;
		let rewindAudio = null;
		let backgroundMusic = null;
		
		let audioStarted = false;
		
		document.addEventListener("DOMContentLoaded", () => {
			clockAudio = document.getElementById("clock-audio");
			clockAudio.volume = 1.0;
			clockAudio.playbackRate = 1.0; // Vitesse normale par d√©faut

			rewindAudio = document.getElementById("rewind-audio");
			if (rewindAudio) rewindAudio.volume = 1.0;
			
			backgroundMusic = document.getElementById("background-music");
			if (backgroundMusic) {
				backgroundMusic.volume = 0.05; // Volume tr√®s faible
				backgroundMusic.playbackRate = 0.5; // Ralenti √† 0.25
				backgroundMusic.loop = true; // Boucle activ√©e
			}
			
			const startClockAudio = () => {
				if (audioStarted) return;
				audioStarted = true;
				
				console.log("üéµ D√©marrage de l'audio...");
				clockAudio.play().catch(e => console.log("Audio play prevented:", e));
				
				// D√©marrer la musique de fond
				if (backgroundMusic) {
					backgroundMusic.play().catch(e => console.log("Background music play prevented:", e));
				}
				
				// D√©marrer la boucle de son al√©atoire
				scheduleRandomSound();
				
				document.removeEventListener("click", startClockAudio);
				document.removeEventListener("keydown", startClockAudio);
			};
			
			document.addEventListener("click", startClockAudio);
			document.addEventListener("keydown", startClockAudio);
			
			// D√©marrer l'audio automatiquement quand on entre en VR
			const scene = document.querySelector("a-scene");
			if (scene) {
				scene.addEventListener("enter-vr", () => {
					console.log("ü•Ω Entr√©e en mode VR d√©tect√©e");
					setTimeout(() => {
						startClockAudio();
					}, 500);
				});
			}
		});
		
		// === RANDOM SFX: Sons al√©atoires avec d√©lai ===
		function scheduleRandomSound() {
			const sfx = document.getElementById("random-sfx");
			if (!sfx) return;
			
			// D√©lai al√©atoire (minimum 3-4 secondes + variation)
			// "pas tout le temps" donc on met une plage assez large, ex: 10 √† 25 secondes apr√®s la fin du pr√©c√©dent
			// Le premier d√©lai est plus court (3-4s) comme demand√©
			const isFirst = !sfx.played.length; 
			const minDelay = isFirst ? 4000 : 15000; 
			const randomDelay = Math.random() * 20000; // + 0 √† 20 sec
			
			const delay = minDelay + randomDelay;
			
			console.log(`Prochain son al√©atoire dans ${(delay/1000).toFixed(1)} sec`);
			
			setTimeout(() => {
				// V√©rifier si le son est en pause (ex: stop zone)
				// Si on veut qu'il joue m√™me en stop zone, on retire la condition
				if (clockAudio && clockAudio.paused) {
					// Si le temps est arr√™t√©, on reporte
					scheduleRandomSound();
					return;
				}
				
				sfx.volume = 0.3;
				sfx.currentTime = 0;
				sfx.play().catch(e => console.log("SFX play prevented:", e));
				
				// Une fois fini, on relance le timer
				sfx.onended = function() {
					scheduleRandomSound();
				};
			}, delay);
		}
		
		// === AUDIO MANAGER: Contr√¥le la vitesse du son ===
		function setClockSpeed(speed) {
			if (clockAudio) {
				clockAudio.playbackRate = speed;
			}
		}
		
		// === PAUSE/RESUME: Arr√™te et reprend le temps ===
		function pauseClockAudio() {
			if (clockAudio && !clockAudio.paused) {
				clockAudio.pause();
			}
			if (backgroundMusic && !backgroundMusic.paused) {
				backgroundMusic.pause();
			}
		}
		
		function resumeClockAudio() {
			if (clockAudio && clockAudio.paused) {
				clockAudio.play().catch(e => console.log("Audio resume prevented:", e));
			}
			if (backgroundMusic && backgroundMusic.paused) {
				backgroundMusic.play().catch(e => console.log("Background music resume prevented:", e));
			}
		}

		// === REWIND AUDIO ===
		function startRewindAudio() {
			if (rewindAudio) {
				rewindAudio.currentTime = 0;
				rewindAudio.play().catch(e => console.log("Rewind play prevented:", e));
			}
		}

		function stopRewindAudio() {
			if (rewindAudio) {
				rewindAudio.pause();
				rewindAudio.currentTime = 0;
			}
		}

		// === SHRINK AUDIO ===
		function playShrinkAudio() {
			var audio = document.getElementById("shrink-sfx");
			if (audio) {
				audio.volume = 0.8;
				audio.currentTime = 0;
				audio.play().catch(e => console.log("Shrink play prevented:", e));
			}
		}

		// === SKYBOX: Contr√¥le l'expansion/contraction de l'espace ===
		function setSpaceScale(scale, duration) {
			const skybox = document.getElementById("skybox");
			if (skybox) {
				skybox.removeAttribute("animation__scale");
				skybox.setAttribute("animation__scale", {
					property: "scale",
					to: scale + " " + scale + " " + scale,
					dur: duration,
					easing: "easeInOutQuad"
				});
			}
		}

		// === SKYBOX ANIMATION: Contr√¥le les animations du fond ===
		function setSkyboxAnimation(mode) {
			const skybox = document.getElementById("skybox");
			if (!skybox) return;
			
			// R√©cup√©rer l'√©tat actuel de rotation et scale
			const currentRotation = skybox.getAttribute("rotation");
			const currentScale = skybox.getAttribute("scale");
			
			// Construire les valeurs "from" √† partir de l'√©tat actuel
			const fromRotation = `${currentRotation.x} ${currentRotation.y} ${currentRotation.z}`;
			const fromScale = `${currentScale.x} ${currentScale.y} ${currentScale.z}`;
			
			// Retirer les animations existantes pour √©viter les conflits
			skybox.removeAttribute("animation");
			skybox.removeAttribute("animation__rotation");
			
			// Petit d√©lai pour laisser le temps aux anciennes animations de s'arr√™ter
			setTimeout(() => {
				if (mode === "stop") {
					// Mode stop : arr√™ter toutes les animations (d√©j√† supprim√©es ci-dessus)
					return;
				} else if (mode === "rewind") {
					// Mode rewind : rotation et scale invers√©s
					skybox.setAttribute("animation", {
						property: "scale",
						from: fromScale,
						to: "1.3 1.2 1.8",
						dur: 8000,
						dir: "alternate",
						loop: true,
						easing: "easeInOutSine"
					});
					skybox.setAttribute("animation__rotation", {
						property: "rotation",
						from: fromRotation,
						to: "-360 90 -360",
						dur: 60000,
						loop: true,
						easing: "easeInOutQuad"
					});
				} else if (mode === "fast") {
					// Mode fast : rotation et scale plus rapides
					skybox.setAttribute("animation", {
						property: "scale",
						from: fromScale,
						to: "1.3 1.2 1.8",
						dur: 4000,
						dir: "alternate",
						loop: true,
						easing: "easeInOutSine"
					});
					skybox.setAttribute("animation__rotation", {
						property: "rotation",
						from: fromRotation,
						to: "720 450 720",
						dur: 30000,
						loop: true,
						easing: "easeInOutQuad"
					});
				} else if (mode === "normal") {
					// Mode normal : reprendre les animations par d√©faut
					skybox.setAttribute("animation", {
						property: "scale",
						from: fromScale,
						to: "1.3 1.2 1.8",
						dur: 8000,
						dir: "alternate",
						loop: true,
						easing: "easeInOutSine"
					});
					skybox.setAttribute("animation__rotation", {
						property: "rotation",
						from: fromRotation,
						to: "360 270 360",
						dur: 60000,
						loop: true,
						easing: "easeInOutQuad"
					});
				}
			}, 100);
		}

		// === BOOKSHELF: Contr√¥le la vitesse d'apparition des livres ===
		let bookSpawnSpeed = 1.0; // Multiplicateur de vitesse (0.5 = lent, 2 = rapide)
		let isInsideBookcase = false; // √âtat: sommes-nous dans la biblioth√®que?
		let bookshelfSpawnerRef = null; // R√©f√©rence au spawner
		
		function setBookSpawnSpeed(speed) {
			bookSpawnSpeed = speed;
		}
		
		// === TESSERACT MODE: Quand on clique sur le livre tomb√© ===
		function enterTesseract() {
			if (isInsideBookcase) return;
			isInsideBookcase = true;
			
			console.log("=== ENTR√âE DANS LE TESSERACT ===");
			
			// Effet de rewind visuel
			playRewindEffect();
			
			// Apr√®s l'effet rewind, t√©l√©porter le joueur
			setTimeout(function() {
				teleportInsideBookcase();
			}, 2000);
		}
		function playRewindEffect() {
			
			// Contracter l'espace
			setSpaceScale(0.3, 1500);
			
			// Flash lumineux
			var flash = document.createElement("a-plane");
			flash.setAttribute("position", "0 1.6 -0.5");
			flash.setAttribute("width", "10");
			flash.setAttribute("height", "10");
			flash.setAttribute("material", "color: white; opacity: 0; transparent: true; shader: flat");
			document.querySelector("a-scene").appendChild(flash);
			
			flash.setAttribute("animation__flash", {
				property: "material.opacity",
				from: 0,
				to: 1,
				dur: 500,
				easing: "easeInQuad"
			});
			
			setTimeout(function() {
				flash.setAttribute("animation__fadeout", {
					property: "material.opacity",
					to: 0,
					dur: 1000,
					easing: "easeOutQuad"
				});
				setTimeout(function() {
					if (flash.parentNode) flash.parentNode.removeChild(flash);
				}, 1100);
			}, 600);
		}
		
		function teleportInsideBookcase() {
			var rig = document.getElementById("rig");
			var camera = document.querySelector("a-camera");
			
			// D√©sactiver les limites normales
			rig.removeAttribute("boundary-limit");
			
			// Cr√©er un effet de tunnel/projection visuel am√©lior√©
			const projectionOverlay = document.createElement("a-plane");
			projectionOverlay.setAttribute("id", "projection-tunnel");
			projectionOverlay.setAttribute("width", "10");
			projectionOverlay.setAttribute("height", "10");
			projectionOverlay.setAttribute("position", "0 0 -0.5");
			projectionOverlay.setAttribute("material", "shader: flat; color: #000000; opacity: 0; transparent: true");
			camera.appendChild(projectionOverlay);
			
			// Cr√©er un effet de vortex/tunnel (sans mouvement de cam√©ra)
			for (var i = 0; i < 12; i++) {
				var ring = document.createElement("a-ring");
				ring.setAttribute("radius-inner", (0.2 + i * 0.3));
				ring.setAttribute("radius-outer", (0.25 + i * 0.3));
				ring.setAttribute("position", "0 0 " + (-0.3 - i * 0.08));
				ring.setAttribute("material", "shader: flat; color: #4488ff; opacity: 0.6; transparent: true");
				ring.setAttribute("class", "tunnel-ring");
				
				// Animation de zoom vers l'int√©rieur (attraction)
				ring.setAttribute("animation__zoom", {
					property: "scale",
					from: "6 6 1",
					to: "0.01 0.01 1",
					dur: 1500 + i * 50,
					easing: "easeInExpo"
				});
				
				// Animation de fondu
				ring.setAttribute("animation__fade", {
					property: "material.opacity",
					from: 0.8,
					to: 0,
					dur: 1500 + i * 50,
					easing: "easeInQuad"
				});
				
				// Animation de rotation pour effet vortex
				ring.setAttribute("animation__rotate", {
					property: "rotation",
					from: "0 0 0",
					to: "0 0 " + (i % 2 === 0 ? 720 : -720),
					dur: 1500,
					easing: "easeInCubic"
				});
				
				camera.appendChild(ring);
			}
			
			// Jouer son de r√©tr√©cissement (violon) avant l'animation
			playShrinkAudio();
			
			// PHASE 1: R√©tr√©cir progressivement AVANT de t√©l√©porter
			// Utilisation de easeInExpo pour un effet d'aspiration soudaine
			rig.setAttribute("animation__shrink", {
				property: "scale",
				from: "1 1 1",
				to: "0.05 0.05 0.05",
				dur: 1500,
				easing: "easeInExpo"
			});
			
			// Ajout : Mouvement vers la biblioth√®que pour donner l'impression d'√™tre aspir√©
			rig.setAttribute("animation__suck", {
				property: "position",
				to: "-0.3 1.5 -1.5",
				dur: 1500,
				easing: "easeInExpo"
			});
			
			// Animation de l'effet tunnel (fondu progressif vers le noir)
			projectionOverlay.setAttribute("animation__fade", {
				property: "material.opacity",
				from: 0,
				to: 1,
				dur: 1400,
				easing: "easeInQuad"
			});
			
			// PHASE 2: Une fois petit, t√©l√©porter instantan√©ment
			setTimeout(function() {
				// T√©l√©portation instantan√©e maintenant qu'on est tout petit
				rig.removeAttribute("animation__suck"); // Arr√™ter l'animation de mouvement
				rig.object3D.position.set(-0.3, 2.1, -2.4);
				console.log("T√©l√©portation effectu√©e");
			}, 1500);
			
			// Fade out apr√®s t√©l√©portation
			setTimeout(function() {
				projectionOverlay.setAttribute("animation__fadeout", {
					property: "material.opacity",
					from: 1,
					to: 0,
					dur: 1000,
					easing: "easeOutQuad"
				});
			}, 1600);
			
			// Remettre l'espace √† la normale
			setTimeout(function() {
				setSpaceScale(1, 1000);
				
				// Retirer l'effet tunnel et les anneaux (avec v√©rification)
				const tunnel = document.getElementById("projection-tunnel");
				if (tunnel && tunnel.parentNode) {
					tunnel.parentNode.removeChild(tunnel);
				}
				var rings = document.querySelectorAll(".tunnel-ring");
				rings.forEach(function(ring) { 
					if (ring && ring.parentNode) {
						ring.parentNode.removeChild(ring); 
					}
				});
				
				// R√©activer les limites adapt√©es au mode miniature
				var rig = document.getElementById("rig");
				rig.setAttribute("boundary-limit", "adaptToScale: true");
				
				// Rendre les livres cliquables pour les faire tomber
				if (bookshelfSpawnerRef) {
					bookshelfSpawnerRef.makeBooksClickable();
				}
				
				console.log("Vous √™tes maintenant DANS la biblioth√®que!");
				console.log("Cliquez sur un livre pour le faire tomber...");
			}, 1800);
		}
		
		function exitTesseract() {
			if (!isInsideBookcase) return;
			isInsideBookcase = false;
			
			var rig = document.getElementById("rig");
			
			// Remettre le joueur √† taille normale
			rig.setAttribute("animation__grow", {
				property: "scale",
				to: "1 1 1",
				dur: 1000,
				easing: "easeInOutQuad"
			});
			
			// T√©l√©porter hors de la biblioth√®que
			rig.setAttribute("animation__teleportout", {
				property: "position",
				to: "0 0 1.5",
				dur: 1000,
				easing: "easeInOutQuad"
			});
			
			// R√©activer les limites
			setTimeout(function() {
				rig.setAttribute("boundary-limit", "");
			}, 1100);
		}

		// === BOOKSHELF SPAWNER: Fait appara√Ætre les livres progressivement ===
		AFRAME.registerComponent("bookshelf-spawner", {
			schema: {
				baseInterval: { type: "number", default: 3000 }, // Intervalle de base en ms
				maxBooks: { type: "number", default: 24 },
				buildDelay: { type: "number", default: 500 } // D√©lai entre chaque planche
			},
			
			// G√©n√®re des positions Z al√©atoires pour chaque √©tage (3-6 livres par √©tage)
			generateRandomBookPositions() {
				const positions = [];
				const etages = [
					{ x: 0.10, y: 1.25 },  // √âtage 1 (bas)
					{ x: 0.10, y: 1.67 },  // √âtage 2 (milieu)
					{ x: 0.10, y: 2.05 },  // √âtage 3 (haut)
					{ x: 0.10, y: 2.45 }   // √âtage 4 (tr√®s haut)
				];
				
				const zMin = -1.2;
				const zMax = 0.2;
				const minSpacing = 0.1;
				
				etages.forEach(etage => {
					// Nombre al√©atoire de livres entre 3 et 6
					const numBooks = Math.floor(Math.random() * 4) + 3;
					const zPositions = [];
					
					// G√©n√©rer des positions Z al√©atoires avec espacement minimum
					let attempts = 0;
					while (zPositions.length < numBooks && attempts < 100) {
						const z = zMin + Math.random() * (zMax - zMin);
						
						// V√©rifier l'espacement avec les autres livres
						let valid = true;
						for (const existingZ of zPositions) {
							if (Math.abs(z - existingZ) < minSpacing) {
								valid = false;
								break;
							}
						}
						
						if (valid) {
							zPositions.push(z);
						}
						attempts++;
					}
					
					// Trier les positions Z pour un placement ordonn√©
					zPositions.sort((a, b) => b - a);
					
					// Ajouter les positions avec l√©g√®re variation sur X
					zPositions.forEach(z => {
						positions.push({
							x: etage.x + (Math.random() * 0.04 - 0.02), // Petite variation X
							y: etage.y,
							z: z
						});
					});
				});
				
				return positions;
			},
			
			init() {
				this.books = [];
				this.bookIndex = 0;
				this.lastSpawnTime = 0;
				this.started = false;
				this.shelfBuilt = false;
				this.buildIndex = 0;
				
				// √âtat du livre tomb√©
				this.fallenBook = null;
				this.fallenBookIndex = -1;
				this.fallenBookOriginalPos = null;
				this.bookHasFallen = false;
				this.fallScheduled = false;
				
				// Tracking pour push progressif (3 clics)
				this.bookPushCounts = [];
				
				// Positions des livres d√©j√† tomb√©s (pour √©viter superposition)
				this.fallenPositions = [];
				
				// Coordonn√©es communes pour la chute
				this.fallTargetX = 1;
				this.fallTargetY = 0.08;
				this.fallTargetZ = 0;
				
				// G√©n√®re des positions al√©atoires pour les livres sur chaque √©tage
				this.bookPositions = this.generateRandomBookPositions();
				
				// Couleurs des livres (24 couleurs)
				this.bookColors = [
					"#8B4513", "#2F4F4F", "#8B0000", "#191970",
					"#006400", "#4B0082", "#B8860B", "#2E8B57",
					"#800000", "#483D8B", "#556B2F", "#8B008B",
					"#CD853F", "#708090", "#DC143C", "#4169E1",
					"#228B22", "#9932CC", "#DAA520", "#20B2AA",
					"#A52A2A", "#6A5ACD", "#808000", "#C71585"
				];
				
				// √âl√©ments de l'√©tag√®re √† construire
				this.shelfParts = [];
				
				// R√©f√©rence pour setTimeout
				const component = this;
				bookshelfSpawnerRef = this; // R√©f√©rence globale
				
				// D√©marrer apr√®s un clic OU automatiquement en VR
				const startSpawning = function() {
					if (component.started) return; // √âviter double d√©marrage
					
					console.log("üìö D√©marrage de l'apparition des livres...");
					component.started = true;
					component.lastSpawnTime = performance.now();
					component.buildShelf();
					console.log("Les livres commencent √† appara√Ætre !");
					
					document.removeEventListener("click", startSpawning);
				};
				
				document.addEventListener("click", startSpawning);
				
				// D√©marrage automatique en mode VR
				const scene = this.el.sceneEl;
				scene.addEventListener("enter-vr", () => {
					console.log("ü•Ω Mode VR d√©tect√© - d√©marrage automatique");
					setTimeout(() => {
						startSpawning();
					}, 1000); // 1 seconde au lieu de 5 pour VR
				});
			},
					buildShelf() {
				// L'√©tag√®re GLB est d√©j√† construite, on peut commencer √† spawner les livres
				this.shelfBuilt = true;
				this.lastSpawnTime = performance.now();
			},
			buildNextPart() {
				if (this.buildIndex >= this.shelfParts.length) {
					this.shelfBuilt = true;
					this.lastSpawnTime = performance.now();
					console.log("√âtag√®re construite!");
					return;
				}
				
				const part = this.shelfParts[this.buildIndex];
				part.setAttribute("animation__build", {
					property: "scale",
					from: "0 0 0",
					to: "1 1 1",
					dur: 400,
					easing: "easeOutBack"
				});
				
				this.buildIndex++;
				setTimeout(() => this.buildNextPart(), this.data.buildDelay);
			},
			removeShelfPart() {
				if (this.buildIndex <= 0) {
					this.shelfBuilt = false;
					console.log("√âtag√®re d√©construite!");
					return;
				}
				
				this.buildIndex--;
				const part = this.shelfParts[this.buildIndex];
				part.setAttribute("animation__unbuild", {
					property: "scale",
					to: "0 0 0",
					dur: 300,
					easing: "easeInBack"
				});
			},
						tick(time) {
				if (!this.started || !this.shelfBuilt) return;
				
				// Mode rewind : faire dispara√Ætre les livres
				if (bookSpawnSpeed < 0) {
					// Si un livre est tomb√©, le remettre en place d'abord
					if (this.bookHasFallen && this.fallenBook) {
						this.unFallBook();
					}
					this.fallScheduled = false;
					
					const adjustedInterval = this.data.baseInterval / Math.abs(bookSpawnSpeed);
					
					if (time - this.lastSpawnTime > adjustedInterval) {
						if (this.books.length > 0) {
							this.removeBook();
						}
						this.lastSpawnTime = time;
					}
					return;
				}
				
				// Mode arr√™t√©
				if (bookSpawnSpeed === 0) return;
				
				// Calculer l'intervalle ajust√© par la vitesse
				const adjustedInterval = this.data.baseInterval / bookSpawnSpeed;
				
				// Continuer √† spawner les livres jusqu'√† la limite
				if (this.bookIndex < this.bookPositions.length) {
					if (time - this.lastSpawnTime > adjustedInterval) {
						this.spawnBook();
						this.lastSpawnTime = time;
					}
				}
				// Si tous les livres sont plac√©s, d√©clencher la chute
				else if (!this.bookHasFallen && !this.fallScheduled) {
					this.fallScheduled = true;
					var comp = this;
					console.log("üéØ TOUS LES LIVRES PLACES!");
					console.log("   - Nombre de livres:", this.books.length);
					console.log("   - BookIndex:", this.bookIndex);
					console.log("   - Positions totales:", this.bookPositions.length);
					console.log("‚è±Ô∏è  Chute programm√©e dans 2 secondes...");
					
					setTimeout(function() {
						console.log("‚è∞ Timer √©coul√©! V√©rifications:");
						console.log("   - bookHasFallen:", comp.bookHasFallen);
						console.log("   - Nombre de livres:", comp.books.length);
						
						if (!comp.bookHasFallen && comp.books.length > 0) {
							console.log("‚úÖ Conditions OK - Lancement de la chute!");
							comp.doBookFall();
						} else {
							console.log("‚ùå Conditions pas remplies - Chute annul√©e");
						}
					}, 2000);
				}
			},
			
			// Faire tomber un livre
			doBookFall: function() {
				if (this.books.length === 0 || this.bookHasFallen) {
					console.log("Abandon chute - books:", this.books.length, "fallen:", this.bookHasFallen);
					return;
				}
				
				console.log("=== CHUTE DU LIVRE ===");
				
				// Choisir un livre al√©atoire
				var idx = Math.floor(Math.random() * this.books.length);
				var book = this.books[idx];
				
				this.fallenBookIndex = idx;
				this.fallenBook = book;
				
				// Sauvegarder position originale
				var pos = book.object3D.position;
				this.fallenBookOriginalPos = { x: pos.x, y: pos.y, z: pos.z };
				
				console.log("Livre", idx, "tombe de", pos.x, pos.y, pos.z);
				
				// R√©cup√©rer dimensions du livre (hauteur = 0.25)
				var bookHeight = 0.25;
				
				// Position de chute commune avec offset selon dimensions
				var newX = this.fallTargetX;
				var newY = this.fallTargetY + (bookHeight / 2);
				var newZ = this.fallTargetZ;
				
// Jouer le son de chute (fichier mp3)
			this.playFallBookAudio();
			// + son synth√©tis√© en arri√®re-plan
				this.playBookFallSound();
				
				// Appliquer animation
				book.setAttribute("animation__bookfall", {
					property: "position",
					to: newX + " " + newY + " " + newZ,
					dur: 2000,
					easing: "easeOutElastic"
				});
				
				book.setAttribute("animation__bookrotate", {
					property: "rotation", 
					to: "0 -90 90",
					dur: 1500,
					easing: "easeOutQuad"
				});
				
				this.bookHasFallen = true;
				
				// Rendre le livre cliquable apr√®s qu'il soit tomb√©
				var component = this;
				setTimeout(function() {
					// Ajouter une zone de clic invisible plus grande
					var clickZone = document.createElement("a-box");
					clickZone.setAttribute("width", "0.5");
					clickZone.setAttribute("height", "0.4");
					clickZone.setAttribute("depth", "0.3");
					clickZone.setAttribute("position", "0 0 0");
					clickZone.setAttribute("material", "opacity: 0; transparent: true");
					clickZone.setAttribute("class", "clickable-fallen-book");
					clickZone.setAttribute("fallen-book-click", "");
					book.appendChild(clickZone);
					
					// Point lumineux blanc au-dessus du livre (livre couch√©)
					var glowSphere = document.createElement("a-sphere");
					glowSphere.setAttribute("radius", "0.04");
					glowSphere.setAttribute("position", "0.4 0 0");
					glowSphere.setAttribute("material", "shader: flat; color: #ffffff; opacity: 0.5; transparent: true");
					glowSphere.setAttribute("animation__pulse", {
						property: "scale",
						from: "0.8 0.8 0.8",
						to: "1.3 1.3 1.3",
						dur: 600,
						dir: "alternate",
						loop: true,
						easing: "easeInOutSine"
					});
					book.appendChild(glowSphere);
					
					// Lumi√®re point blanche qui √©claire le livre
					var glowLight = document.createElement("a-light");
					glowLight.setAttribute("type", "point");
					glowLight.setAttribute("color", "#ffffff");
					glowLight.setAttribute("intensity", "1.5");
					glowLight.setAttribute("distance", "5");
					glowLight.setAttribute("decay", "1");
					glowLight.setAttribute("position", "0 0.20 0");
					glowLight.setAttribute("animation__blink", {
						property: "intensity",
						from: 0.8,
						to: 2.5,
						dur: 600,
						dir: "alternate",
						loop: true,
						easing: "easeInOutSine"
					});
					book.appendChild(glowLight);
					
					console.log("Livre tomb√© maintenant cliquable!");
				}, 2100);
				
				console.log("Animation de chute lanc√©e!");
			},
			
			// Rendre tous les livres cliquables (mode tesseract)
			makeBooksClickable: function() {
				var comp = this;
				// Initialiser compteurs de push
				this.bookPushCounts = new Array(this.books.length).fill(0);
				
				// Configurer le raycaster pour d√©tecter les livres √† petite √©chelle
				var cursor = document.querySelector("a-cursor");
				if (cursor) {
					cursor.setAttribute("raycaster", "objects: .clickable-fallen-book, .pushable-book; far: 1000");
				}
				
				console.log("Configuration raycaster pour " + this.books.length + " livres");
				
				this.books.forEach(function(book, index) {
					// Ajouter une zone de clic pr√©cise sur chaque livre
					var clickZone = document.createElement("a-box");
					clickZone.setAttribute("width", "0.12");
					clickZone.setAttribute("height", "0.28");
					clickZone.setAttribute("depth", "0.20");
					clickZone.setAttribute("position", "0 0 0");
					clickZone.setAttribute("material", "opacity: 0; transparent: true; side: double");
					clickZone.setAttribute("class", "pushable-book");
					clickZone.setAttribute("pushable-book", "index: " + index);
					book.appendChild(clickZone);
					console.log("Zone clic ajout√©e au livre " + index);
				});
				console.log("Livres rendus poussables!");
			},
			
			// Faire tomber un livre sp√©cifique (pouss√© par le joueur)
			pushBookByIndex: function(index) {
				if (index < 0 || index >= this.books.length) return;
				
				// Pousser directement le livre cliqu√© (celui dans le viseur)
				var book = this.books[index];
				var pos = book.object3D.position;
				
				// Incr√©menter compteur de push
				this.bookPushCounts[index]++;
				var pushCount = this.bookPushCounts[index];
				
				console.log("=== PUSH " + pushCount + "/3 sur livre " + index + " ===");
				
				if (pushCount < 3) {
					// Push progressif - d√©placer l√©g√®rement vers l'avant (vers le joueur = +X)
					var pushDistance = 0.08;
					var newX = pos.x + pushDistance;
					
					book.setAttribute("animation__push" + pushCount, {
						property: "position",
						to: newX + " " + pos.y + " " + pos.z,
						dur: 300,
						easing: "easeOutQuad"
					});
					
					// Petit son de pouss√©e
					var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
					var osc = audioCtx.createOscillator();
					var gain = audioCtx.createGain();
					osc.connect(gain);
					gain.connect(audioCtx.destination);
					osc.frequency.value = 200;
					gain.gain.value = 0.1;
					osc.start();
					osc.stop(audioCtx.currentTime + 0.05);
				} else {
					// 3√®me push - le livre tombe!
					console.log("üìñ LIVRE TOMBE!");
					
					// Son de chute
				this.playFallBookAudio();
					
					// R√©cup√©rer dimensions
					var bookHeight = 0.25;
					
					// Trouver une position de chute unique (sans superposition)
					var newX, newZ;
					var attempts = 0;
					var minDistance = 0.35; // Distance minimum entre les livres
					var comp = this;
					
					do {
						newX = this.fallTargetX + (Math.random() - 0.5) * 1.5;
						newZ = this.fallTargetZ + (Math.random() - 0.5) * 1.5;
						attempts++;
						
						// V√©rifier distance avec les livres d√©j√† tomb√©s
						var tooClose = this.fallenPositions.some(function(p) {
							var dx = newX - p.x;
							var dz = newZ - p.z;
							return Math.sqrt(dx*dx + dz*dz) < minDistance;
						});
					} while (tooClose && attempts < 20);
					
					// Enregistrer cette position
					this.fallenPositions.push({x: newX, z: newZ});
					
					var newY = this.fallTargetY + (bookHeight / 2);
					
					book.setAttribute("animation__pushed", {
						property: "position",
						to: newX + " " + newY + " " + newZ,
						dur: 1500,
						easing: "easeOutElastic"
					});
					
					book.setAttribute("animation__pushedrotate", {
						property: "rotation",
						to: "0 -90 90",
						dur: 1200,
						easing: "easeOutQuad"
					});
					
					// Apr√®s la chute, proposer de sortir
					setTimeout(function() {
						console.log("Vous venez de faire tomber le livre que vous avez ramass√©!");
						console.log("Appuyez sur √âchap pour revenir...");
					}, 2000);
				}
			},
			
			// Jouer le fichier audio de chute de livre
			playFallBookAudio: function() {
				var audio = document.getElementById("fall-book-sfx");
				if (audio) {
					audio.volume = 0.7;
					audio.currentTime = 0;
					audio.play().catch(e => console.log("Fall book play prevented:", e));
				}
			},
			
			// Jouer un son de chute de livre (synth√©tis√©)
			playBookFallSound: function() {
				try {
					var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
					
					// Cr√©er un son de chute (bruit basse fr√©quence + impact)
					var oscillator = audioCtx.createOscillator();
					var gainNode = audioCtx.createGain();
					
					oscillator.connect(gainNode);
					gainNode.connect(audioCtx.destination);
					
					// Bruit d'impact grave
					oscillator.frequency.value = 80;
					oscillator.type = 'sine';
					
					// Envelope pour simuler un impact
					gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
					
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.3);
					
					// Ajouter un deuxi√®me son pour le "thud"
					var oscillator2 = audioCtx.createOscillator();
					var gainNode2 = audioCtx.createGain();
					
					oscillator2.connect(gainNode2);
					gainNode2.connect(audioCtx.destination);
					
					oscillator2.frequency.value = 120;
					oscillator2.type = 'triangle';
					
					gainNode2.gain.setValueAtTime(0.2, audioCtx.currentTime + 1.1);
					gainNode2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.3);
					
					oscillator2.start(audioCtx.currentTime + 1.1);
					oscillator2.stop(audioCtx.currentTime + 1.3);
				} catch(e) {
					console.log("Erreur audio:", e);
				}
			},
			
			// Remettre le livre tomb√© en place (rewind)
			unFallBook: function() {
				if (!this.fallenBook || !this.fallenBookOriginalPos) return;
				
				var origPos = this.fallenBookOriginalPos;
				var book = this.fallenBook;
				
				console.log("Remise en place du livre");
				
				// Animation inverse
				book.removeAttribute("animation__bookfall");
				book.removeAttribute("animation__bookrotate");
				
				book.setAttribute("animation__bookunfall", {
					property: "position",
					to: origPos.x + " " + origPos.y + " " + origPos.z,
					dur: 600,
					easing: "easeOutQuad"
				});
				
				book.setAttribute("animation__bookunrotate", {
					property: "rotation",
					to: "0 -90 0",
					dur: 600,
					easing: "easeInOutQuad"
				});
				
				this.bookHasFallen = false;
				this.fallenBook = null;
				this.fallenBookIndex = -1;
				this.fallenBookOriginalPos = null;
			},
			removeBook() {
				if (this.books.length === 0) return;
				
				const book = this.books.pop();
				this.bookIndex--;
				
				// Animation de disparition
				book.setAttribute("animation__vanish", {
					property: "scale",
					to: "0 0 0",
					dur: 400,
					easing: "easeInBack"
				});
				book.setAttribute("animation__rise", {
					property: "position",
					to: `${book.getAttribute("position").x} ${book.getAttribute("position").y + 0.5} ${book.getAttribute("position").z}`,
					dur: 400,
					easing: "easeInQuad"
				});
				
				// Supprimer apr√®s animation
				setTimeout(() => {
					if (book.parentNode) {
						book.parentNode.removeChild(book);
					}
				}, 450);
				
				console.log("Livre retir√©:", this.bookIndex, "restants");
			},
			spawnBook() {
				if (this.bookIndex >= this.bookPositions.length) return;
				
				const pos = this.bookPositions[this.bookIndex];
				const color = this.bookColors[this.bookIndex % this.bookColors.length];
				
				// G√©n√©rer une couleur de tranche plus claire
				const spineColor = this.lightenColor(color, 30);
				const pageColor = "#f5f0e6";
				
				// Cr√©er le conteneur du livre
				const book = document.createElement("a-entity");
				const bookY = this.el.getAttribute("position").y + pos.y;
				book.setAttribute("position", `${pos.x} ${bookY} ${pos.z}`);
				book.setAttribute("rotation", "0 -90 0");
				book.setAttribute("scale", "0 0 0");
				
				// Couverture principale (avant)
				const cover = document.createElement("a-box");
				cover.setAttribute("width", "0.02");
				cover.setAttribute("height", "0.25");
				cover.setAttribute("depth", "0.18");
				cover.setAttribute("position", "0.03 0 0");
				cover.setAttribute("material", `src: #book-pattern; color: ${color}; metalness: 0.1; roughness: 0.7`);
				cover.setAttribute("shadow", "cast: true; receive: true");
				book.appendChild(cover);
				
				// Pages (int√©rieur blanc/cr√®me)
				const pages = document.createElement("a-box");
				pages.setAttribute("width", "0.05");
				pages.setAttribute("height", "0.23");
				pages.setAttribute("depth", "0.16");
				pages.setAttribute("position", "0 0 0");
				pages.setAttribute("material", `color: ${pageColor}; roughness: 0.9`);
				pages.setAttribute("shadow", "cast: true; receive: true");
				book.appendChild(pages);
				
				// Dos du livre (couverture arri√®re)
				const back = document.createElement("a-box");
				back.setAttribute("width", "0.02");
				back.setAttribute("height", "0.25");
				back.setAttribute("depth", "0.18");
				back.setAttribute("position", "-0.03 0 0");
				back.setAttribute("material", `src: #book-pattern; color: ${color}; metalness: 0.1; roughness: 0.7`);
				back.setAttribute("shadow", "cast: true; receive: true");
				book.appendChild(back);
				
				// Tranche (spine) - partie visible sur l'√©tag√®re
				const spine = document.createElement("a-box");
				spine.setAttribute("width", "0.081");
				spine.setAttribute("height", "0.251");
				spine.setAttribute("depth", "0.02");
				spine.setAttribute("position", "0 0 -0.09");
				spine.setAttribute("material", `src: #book-pattern; color: ${spineColor}; metalness: 0.2; roughness: 0.6`);
				spine.setAttribute("shadow", "cast: true; receive: true");
				book.appendChild(spine);
				
				this.el.appendChild(book);
				
				// Animation d'apparition (scale up)
				setTimeout(() => {
					book.setAttribute("animation__scale", {
						property: "scale",
						from: "0 0 0",
						to: "1 1 1",
						dur: 500,
						easing: "easeOutBack"
					});
					
					// Animation de descente vers l'√©tag√®re
					book.setAttribute("animation__fall", {
						property: "position",
						to: `${pos.x} ${pos.y} ${pos.z}`,
						dur: 800,
						easing: "easeOutElastic",
						delay: 200
					});
				}, 50);
				
				this.books.push(book);
				this.bookIndex++;
				
				console.log("Livre apparu:", this.bookIndex, "/ 12");
			},
			
			// √âclaircir une couleur hex
			lightenColor(hex, percent) {
				const num = parseInt(hex.replace('#', ''), 16);
				const amt = Math.round(2.55 * percent);
				const R = Math.min(255, (num >> 16) + amt);
				const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
				const B = Math.min(255, (num & 0x0000FF) + amt);
				return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
			}
		});

		// === FALLEN BOOK CLICK: Composant pour cliquer sur le livre tomb√© ===
		AFRAME.registerComponent("fallen-book-click", {
			init: function() {
				var el = this.el;
				
				// Ajouter un glow pour montrer que c'est cliquable
				el.setAttribute("animation__glow", {
					property: "scale",
					from: "1 1 1",
					to: "1.05 1.05 1.05",
					dur: 800,
					dir: "alternate",
					loop: true,
					easing: "easeInOutSine"
				});
				
				el.addEventListener("click", function() {
					console.log("Livre tomb√© cliqu√©!");
					enterTesseract();
				});
				
				el.addEventListener("mouseenter", function() {
					el.setAttribute("animation__highlight", {
						property: "scale",
						to: "1.1 1.1 1.1",
						dur: 200,
						easing: "easeOutQuad"
					});
				});
				
				el.addEventListener("mouseleave", function() {
					el.removeAttribute("animation__highlight");
				});
			}
		});
		
		// === PUSHABLE BOOK: Composant pour pousser les livres depuis le tesseract ===
		AFRAME.registerComponent("pushable-book", {
			schema: {
				index: { type: "int", default: 0 }
			},
			init: function() {
				var el = this.el;
				var index = this.data.index;
				
				el.addEventListener("click", function(evt) {
					console.log("=== CLICK d√©tect√© sur livre " + index + " ===");
					
					// V√©rifier que c'est bien le livre le plus proche du raycaster
					var camera = document.querySelector("a-camera");
					var cursor = document.querySelector("a-cursor");
					if (cursor && cursor.components.raycaster) {
						var intersections = cursor.components.raycaster.intersections;
						
						if (intersections.length > 0) {
							// Trouver le livre le plus proche
							var closestBookIndex = -1;
							var closestDistance = Infinity;
							
							for (var i = 0; i < intersections.length; i++) {
								var obj = intersections[i].object.el;
								if (obj && obj.classList.contains("pushable-book") && obj.components["pushable-book"]) {
									var bookIdx = obj.components["pushable-book"].data.index;
									if (intersections[i].distance < closestDistance) {
										closestDistance = intersections[i].distance;
										closestBookIndex = bookIdx;
									}
								}
							}
							
							// Si ce n'est pas le livre le plus proche, ignorer le clic
							if (closestBookIndex !== index) {
								console.log("Clic ignor√© - livre " + closestBookIndex + " plus proche que " + index);
								return;
							}
						}
					}
					
					if (bookshelfSpawnerRef) {
						console.log("bookshelfSpawnerRef trouv√©, appel pushBookByIndex pour livre " + index);
						bookshelfSpawnerRef.pushBookByIndex(index);
					} else {
						console.log("ERREUR: bookshelfSpawnerRef est null!");
					}
				});
				
				el.addEventListener("mouseenter", function() {
					el.setAttribute("animation__pushhover", {
						property: "scale",
						to: "1.1 1.1 1.1",
						dur: 150,
						easing: "easeOutQuad"
					});
				});
				
				el.addEventListener("mouseleave", function() {
					el.setAttribute("animation__pushleave", {
						property: "scale",
						to: "1 1 1",
						dur: 150,
						easing: "easeOutQuad"
					});
				});
			}
		});
		
		// === TOUCHE √âCHAP pour sortir du tesseract ===
		document.addEventListener("keydown", function(e) {
			if (e.key === "Escape" && isInsideBookcase) {
				exitTesseract();
			}
		});

		// === VR CONTROLLER LOCOMOTION: D√©placement avec les joysticks des manettes VR ===
		AFRAME.registerComponent("vr-controller-movement", {
			schema: {
				speed: { type: "number", default: 3.0 },
				rotationSpeed: { type: "number", default: 45 }
			},
			init() {
				this.leftStickX = 0;
				this.leftStickY = 0;
				this.rightStickX = 0;
				this.direction = new THREE.Vector3();
				this.rotationAxis = new THREE.Vector3(0, 1, 0);
				this.debugTimer = 0;
				
				console.log("üéÆ VR Controller Movement initialis√©");
			},
			tick(time, delta) {
				if (!delta) return;
				
				const deltaSeconds = delta / 1000;
				const data = this.data;
				
				// R√©cup√©rer les gamepads VR
				const gamepads = navigator.getGamepads();
				if (!gamepads) return;
				
				this.leftStickX = 0;
				this.leftStickY = 0;
				this.rightStickX = 0;
				
				let hasGamepad = false;
				
				// Lire tous les gamepads
				for (let i = 0; i < gamepads.length; i++) {
					const gamepad = gamepads[i];
					if (!gamepad) continue;
					
					hasGamepad = true;
					
					// Debug: afficher les axes toutes les 2 secondes
					this.debugTimer += delta;
					if (this.debugTimer > 2000) {
						console.log(`üéÆ Gamepad ${i} (${gamepad.hand || 'unknown'}):`, {
							id: gamepad.id,
							axes: gamepad.axes.slice(0, 4),
							buttons: gamepad.buttons.length
						});
						this.debugTimer = 0;
					}
					
					// Axes 2 et 3 sont g√©n√©ralement le thumbstick principal
					if (gamepad.axes.length >= 4) {
						// Main gauche - d√©placement
						if (gamepad.hand === 'left') {
							this.leftStickX = Math.abs(gamepad.axes[2]) > 0.15 ? gamepad.axes[2] : 0;
							this.leftStickY = Math.abs(gamepad.axes[3]) > 0.15 ? gamepad.axes[3] : 0;
						}
						// Main droite - rotation
						else if (gamepad.hand === 'right') {
							this.rightStickX = Math.abs(gamepad.axes[2]) > 0.15 ? gamepad.axes[2] : 0;
						}
					}
					// Fallback si hand n'est pas d√©fini
					else if (gamepad.axes.length >= 2) {
						if (i === 0) { // Premier contr√¥leur = gauche par d√©faut
							this.leftStickX = Math.abs(gamepad.axes[0]) > 0.15 ? gamepad.axes[0] : 0;
							this.leftStickY = Math.abs(gamepad.axes[1]) > 0.15 ? gamepad.axes[1] : 0;
						} else if (i === 1) { // Second contr√¥leur = droit par d√©faut
							this.rightStickX = Math.abs(gamepad.axes[0]) > 0.15 ? gamepad.axes[0] : 0;
						}
					}
				}
				
				// D√©placement avec joystick gauche
				if (this.leftStickX !== 0 || this.leftStickY !== 0) {
					const cameraEl = this.el.querySelector('a-camera');
					if (!cameraEl) return;
					
					// Obtenir la rotation de la cam√©ra
					const cameraRotation = cameraEl.object3D.rotation;
					const yaw = cameraRotation.y;
					
					// Calculer la direction bas√©e sur le stick et la rotation de la cam√©ra
					this.direction.set(
						this.leftStickX,
						0,
						-this.leftStickY // Inverser Y
					);
					
					this.direction.applyAxisAngle(this.rotationAxis, yaw);
					this.direction.normalize();
					
					// Appliquer la vitesse
					const speed = data.speed * deltaSeconds;
					this.direction.multiplyScalar(speed);
					
					// D√©placer le rig
					const pos = this.el.object3D.position;
					pos.x += this.direction.x;
					pos.z += this.direction.z;
				}
				
				// Rotation avec joystick droit
				if (this.rightStickX !== 0) {
					const rotationDelta = this.rightStickX * data.rotationSpeed * deltaSeconds;
					const rot = this.el.object3D.rotation;
					rot.y += THREE.MathUtils.degToRad(rotationDelta);
				}
			}
		});

		// === BOUNDARY: Bloque l'utilisateur dans le cube 4x4x4 ===
		AFRAME.registerComponent("boundary-limit", {
			schema: {
				minX: { type: "number", default: -2 },
				maxX: { type: "number", default: 2 },
				minZ: { type: "number", default: -2 },
				maxZ: { type: "number", default: 2 },
				minY: { type: "number", default: 0 },
				maxY: { type: "number", default: 4 },
				adaptToScale: { type: "boolean", default: true }
			},
			init() {
				this.camPos = new THREE.Vector3();
			},
			tick() {
				const camera = this.el.sceneEl.camera;
				if (!camera) return;
				
				// Obtenir position monde de la cam√©ra
				camera.getWorldPosition(this.camPos);
				
				const d = this.data;
				let needsClamp = false;
				let clampedX = this.camPos.x;
				let clampedY = this.camPos.y;
				let clampedZ = this.camPos.z;
				
				// Si mode miniature, adapter les limites
				let minX = d.minX, maxX = d.maxX, minZ = d.minZ, maxZ = d.maxZ;
				let minY = d.minY, maxY = d.maxY;
				
				if (d.adaptToScale && isInsideBookcase) {
					// Limites adapt√©es pour scale 0.05 - zone r√©duite pour √©viter le vide
					const halfSize = 0.12; // Zone plus petite pour rester dans l'armoire
					const basePos = {x: -0.3, y: 2.1, z: -2.5};
					minX = basePos.x - halfSize;
					maxX = basePos.x + halfSize;
					minY = basePos.y - halfSize;
					maxY = basePos.y + halfSize;
					minZ = basePos.z - halfSize;
					maxZ = basePos.z + halfSize;
				}
				
				// V√©rifier limites X
				if (this.camPos.x < minX) { clampedX = minX; needsClamp = true; }
				if (this.camPos.x > maxX) { clampedX = maxX; needsClamp = true; }
				
				// V√©rifier limites Y
				if (this.camPos.y < minY) { clampedY = minY; needsClamp = true; }
				if (this.camPos.y > maxY) { clampedY = maxY; needsClamp = true; }
				
				// V√©rifier limites Z
				if (this.camPos.z < minZ) { clampedZ = minZ; needsClamp = true; }
				if (this.camPos.z > maxZ) { clampedZ = maxZ; needsClamp = true; }
				
				// Si hors limites, repositionner le rig
				if (needsClamp) {
					const rigPos = this.el.object3D.position;
					rigPos.x += (clampedX - this.camPos.x);
					rigPos.y += (clampedY - this.camPos.y);
					rigPos.z += (clampedZ - this.camPos.z);
				}
			}
		});

		// === TIME ZONE: D√©tection de pr√©sence dans les cercles ===
		AFRAME.registerComponent("time-zone", {
			schema: {
				mode: { type: "string", default: "slow" },
				radius: { type: "number", default: 1.0 },
				lightSpeed: { type: "number", default: 5000 },
				beamColor: { type: "string", default: "#ffffff" },
				needleSpeed: { type: "number", default: 3000 }
			},
			init() {
				this.active = false;
				this.light = null;
				this.needleMinute = null;
				this.needleHour = null;
				this.skyBeam = null;
				this.zoneCenter = new THREE.Vector3();
				
				// Trouver les √©l√©ments associ√©s
				const id = this.el.id;
				let beamColor = "#ffd080";
				if (id === "zone-left") {
					this.light = document.getElementById("light-left");
					this.needleMinute = document.getElementById("needle-minute-left");
					this.needleHour = document.getElementById("needle-hour-left");
					beamColor = "#9080ff";
				} else if (id === "zone-right") {
					this.light = document.getElementById("light-right");
					this.needleMinute = document.getElementById("needle-minute-right");
					this.needleHour = document.getElementById("needle-hour-right");
					beamColor = "#ff80a0";
				} else if (id === "zone-center") {
					this.light = document.getElementById("light-center");
					this.needleMinute = document.getElementById("needle-minute-center");
					this.needleHour = document.getElementById("needle-hour-center");
					beamColor = "#ffd080";
				}
				
				// Cr√©er le faisceau lumineux du ciel au-dessus de la biblioth√®que
				this.skyBeam = document.createElement("a-cylinder");
				this.skyBeam.setAttribute("radius", "1.4");
				this.skyBeam.setAttribute("height", "10");
				this.skyBeam.setAttribute("position", "0 5 -2.5"); // Position de la biblioth√®que
				this.skyBeam.setAttribute("material", `color: ${beamColor}; opacity: 0; transparent: true; side: double; emissive: ${beamColor}; emissiveIntensity: 0.15; depthWrite: false`);
				this.skyBeam.setAttribute("scale", "1 1 1");
				// Ajouter √† la sc√®ne et non au cercle
				this.el.sceneEl.appendChild(this.skyBeam);
			},
			tick() {
				// R√©cup√©rer la cam√©ra
				const camera = this.el.sceneEl.camera;
				if (!camera) return;
				
				// Position de la cam√©ra dans le monde
				const camPos = new THREE.Vector3();
				camera.getWorldPosition(camPos);
				
				// Position du cercle
				this.el.object3D.getWorldPosition(this.zoneCenter);
				
				// Distance horizontale uniquement (ignorer Y)
				const dx = camPos.x - this.zoneCenter.x;
				const dz = camPos.z - this.zoneCenter.z;
				const dist = Math.sqrt(dx * dx + dz * dz);
				
				const wasActive = this.active;
				this.active = dist < this.data.radius;
				
				if (this.active && !wasActive) {
					this.enterZone();
				} else if (!this.active && wasActive) {
					this.leaveZone();
				}
			},
			enterZone() {
				console.log("ENTER:", this.data.mode);
				
				// Changer la vitesse du son et l'√©chelle de l'espace
				if (this.data.mode === "slow") {
					setClockSpeed(0.5); // Ralenti x0.5
					setSpaceScale(1.5, 2000); // Espace s'√©tend
					setBookSpawnSpeed(0.3); // Livres apparaissent lentement
					setSkyboxAnimation("normal"); // Animation normale
				} else if (this.data.mode === "fast") {
					setClockSpeed(2.0); // Acc√©l√©r√© x2
					setSpaceScale(0.6, 1000); // Espace se contracte
					setBookSpawnSpeed(4.0); // Livres apparaissent rapidement
					setSkyboxAnimation("fast"); // Animation plus rapide
				} else if (this.data.mode === "rewind") {
					if (clockAudio && !clockAudio.paused) {
						clockAudio.pause(); // Arr√™ter juste le son d'horloge
					}
					startRewindAudio(); // Jouer le son sp√©cial rewind
					setSpaceScale(0.8, 1500); // L√©g√®re contraction
					setBookSpawnSpeed(-2.0); // Livres disparaissent (n√©gatif = rewind)
					setSkyboxAnimation("rewind"); // Animation sens inverse
				} else if (this.data.mode === "stop") {
					pauseClockAudio(); // Arr√™ter le temps (pause audio)
					setSpaceScale(1.2, 500); // L√©g√®re expansion
					setBookSpawnSpeed(0); // Livres fig√©s
					setSkyboxAnimation("stop"); // Arr√™ter l'animation du fond
				}
				
				// Activer le faisceau lumineux du ciel
				if (this.skyBeam) {
					this.skyBeam.removeAttribute("animation__beam");
					this.skyBeam.setAttribute("animation__beam", {
						property: "material.opacity",
						from: 0,
						to: 0.1,
						dur: 500,
						easing: "easeOutQuad"
					});
				}
				
				// Activer l'aiguille des minutes (rotation rapide) - SAUF en mode stop
				// Sens horaire normal = n√©gatif en Y (vue de dessus), rewind = positif
				if (this.needleMinute && this.data.mode !== "stop") {
					const rotDir = this.data.mode === "rewind" ? "360" : "-360";
					// Reset la rotation avant de relancer l'animation
					this.needleMinute.setAttribute("rotation", "0 0 0");
					this.needleMinute.setAttribute("animation__spin", {
						property: "rotation",
						from: "0 0 0",
						to: "0 " + rotDir + " 0",
						loop: true,
						dur: this.data.needleSpeed,
						easing: "linear"
					});
				}
				
				// Activer l'aiguille des heures (12x plus lente) - SAUF en mode stop
				if (this.needleHour && this.data.mode !== "stop") {
					const rotDir = this.data.mode === "rewind" ? "360" : "-360";
					// Reset la rotation avant de relancer l'animation
					this.needleHour.setAttribute("rotation", "0 0 0");
					this.needleHour.setAttribute("animation__spin", {
						property: "rotation",
						from: "0 0 0",
						to: "0 " + rotDir + " 0",
						loop: true,
						dur: this.data.needleSpeed * 12,
						easing: "linear"
					});
				}
			},
			leaveZone() {
				console.log("LEAVE:", this.data.mode);
				
				// Si on quitte la zone rewind, arr√™ter son sp√©cial et reprendre normal
				if (this.data.mode === "rewind") {
					stopRewindAudio();
					resumeClockAudio();
				}

				// Si on quitte la zone stop, reprendre le son
				if (this.data.mode === "stop") {
					resumeClockAudio();
				}
				
				// Revenir √† la vitesse normale
				setClockSpeed(1.0);
				
				// Revenir √† l'√©chelle normale de l'espace
				setSpaceScale(1, 1500);
				
				// Revenir √† la vitesse normale des livres
				setBookSpawnSpeed(1.0);
				
				// Reprendre l'animation normale du fond
				setSkyboxAnimation("normal");
				
				// D√©sactiver le faisceau lumineux
				if (this.skyBeam) {
					this.skyBeam.removeAttribute("animation__beam");
					this.skyBeam.setAttribute("animation__beam", {
						property: "material.opacity",
						to: 0,
						dur: 300,
						easing: "easeInQuad"
					});
				}
				
				// D√©sactiver les aiguilles et r√©initialiser leur rotation
				if (this.needleMinute) {
					this.needleMinute.removeAttribute("animation__spin");
					this.needleMinute.setAttribute("rotation", "0 0 0");
				}
				if (this.needleHour) {
					this.needleHour.removeAttribute("animation__spin");
					this.needleHour.setAttribute("rotation", "0 0 0");
				}
			}
		});
	</script>
</head>
<body>
	<!-- Son d'horloge en fond -->
	<audio id="clock-audio" loop>
		<source src="./Echoing Clock Tick  HQ Sound Effect (online-video-cutter.com).mp3" type="audio/mpeg">
	</audio>
	<!-- Son al√©atoire (Attack on Titan) -->
	<audio id="random-sfx">
		<source src="./Attack on Titan Season 1 Episode Title Sound Effect.mp3" type="audio/mpeg">
	</audio>
	<!-- Son Rewind -->
	<audio id="rewind-audio" loop>
		<source src="./horloge rewind en mp3.mp3" type="audio/mpeg">
	</audio>
	<!-- Son Chute de Livre -->
	<audio id="fall-book-sfx">
		<source src="./fall book.mp3" type="audio/mpeg">
	</audio>
	<!-- Son R√©tr√©cissement -->
	<audio id="shrink-sfx">
		<source src="./violin-glissando-10-97632.mp3" type="audio/mpeg">
	</audio>
	<!-- Son de fond - Octopus's Garden -->
	<audio id="background-music" loop>
		<source src="./592534__voxlab__octopussys-garden-synth-pad-dmin7-chord.wav" type="audio/wav">
	</audio>

	<a-scene shadow="type: pcfsoft" renderer="colorManagement: true; exposure: 1.2">
		<!-- Assets - ne bloque pas la sc√®ne si les mod√®les mettent du temps -->
		<a-assets timeout="10000">
			<img id="space360" src="./image2.png" crossorigin="anonymous">
			<img id="metal-texture" src="./Poliigon_MetalPaintedMatte_7037_Preview1.png" crossorigin="anonymous">
			<img id="book-pattern" src="./book_pattern_disp_4k.png" crossorigin="anonymous">
		</a-assets>

		<!-- √âclairage ambiant -->
		<a-entity light="type: ambient; color: #6080a0; intensity: 0.5"></a-entity>
		<a-entity light="type: directional; color: #ffe0c0; intensity: 0.4" position="1 3 1"></a-entity>

		<!-- Skybox 360 (monde ext√©rieur) -->
		<a-sky id="skybox" src="#space360" rotation="0 -90 0" scale="1.8 1 1.3" 
		       animation="property: scale; to: 1.3 1.2 1.8; dur: 8000; dir: alternate; loop: true; easing: easeInOutSine"
		       animation__rotation="property: rotation; to: 5 -85 -3; dur: 12000; dir: alternate; loop: true; easing: easeInOutQuad"></a-sky>

		<!-- Cube 4x4x4 (limites invisibles) -->

		<!-- ========== CERCLE GAUCHE (REWIND) ========== -->
		<a-entity id="zone-left" position="-1.8 0.01 0" 
			time-zone="mode: rewind; radius: 0.55; lightSpeed: 4000; needleSpeed: 2000">
			
			<!-- Anneau violet avec texture m√©tal -->
			<a-ring radius-inner="0.42" radius-outer="0.55" rotation="-90 0 0" 
				material="src: #metal-texture; color: #6a5acd; opacity: 0.9; metalness: 0.4; roughness: 0.55"></a-ring>
			<a-ring radius-inner="0.18" radius-outer="0.26" rotation="-90 0 0" 
				material="src: #metal-texture; color: #6a5acd; opacity: 0.6; metalness: 0.4; roughness: 0.55"></a-ring>
			
			<!-- Aiguille des minutes (longue, rapide) -->
			<a-entity id="needle-minute-left" position="0 0.03 0" rotation="0 0 0">
				<a-box width="0.40" height="0.015" depth="0.020" position="0.17 0 0" 
					material="src: #metal-texture; color: #6a5acd; metalness: 0.4; roughness: 0.55"></a-box>
			</a-entity>
			
			<!-- Aiguille des heures (courte, lente) -->
			<a-entity id="needle-hour-left" position="0 0.05 0" rotation="0 90 0">
				<a-box width="0.28" height="0.020" depth="0.025" position="0.10 0 0" 
					material="src: #metal-texture; color: #483d8b; metalness: 0.4; roughness: 0.55"></a-box>
			</a-entity>
		</a-entity>

		<!-- Lumi√®re gauche -->
		<a-entity id="light-left" position="-1.8 1.2 0">
			<a-entity light="type: spot; color: #9080ff; intensity: 0; angle: 45; penumbra: 0.5; castShadow: true" 
				position="0 0 0" rotation="-90 0 0"></a-entity>
		</a-entity>

		<!-- ========== CERCLE DROIT (FAST) ========== -->
		<a-entity id="zone-right" position="1.8 0.01 0" 
			time-zone="mode: fast; radius: 0.55; lightSpeed: 1500; needleSpeed: 800">
			
			<!-- Anneau rose avec texture m√©tal -->
			<a-ring radius-inner="0.42" radius-outer="0.55" rotation="-90 0 0" 
				material="src: #metal-texture; color: #e85f8d; opacity: 0.9; metalness: 0.4; roughness: 0.55"></a-ring>
			<a-ring radius-inner="0.18" radius-outer="0.26" rotation="-90 0 0" 
				material="src: #metal-texture; color: #e85f8d; opacity: 0.6; metalness: 0.4; roughness: 0.55"></a-ring>
			
			<!-- Aiguille des minutes (longue, rapide) -->
			<a-entity id="needle-minute-right" position="0 0.03 0" rotation="0 0 0">
				<a-box width="0.40" height="0.015" depth="0.020" position="0.17 0 0" 
					material="src: #metal-texture; color: #e85f8d; metalness: 0.4; roughness: 0.55"></a-box>
			</a-entity>
			
			<!-- Aiguille des heures (courte, lente) -->
			<a-entity id="needle-hour-right" position="0 0.05 0" rotation="0 90 0">
				<a-box width="0.28" height="0.020" depth="0.025" position="0.10 0 0" 
					material="src: #metal-texture; color: #d04a78; metalness: 0.4; roughness: 0.55"></a-box>
			</a-entity>
		</a-entity>

		<!-- Lumi√®re droite -->
		<a-entity id="light-right" position="1.8 1.2 0">
			<a-entity light="type: spot; color: #ff80a0; intensity: 0; angle: 45; penumbra: 0.5; castShadow: true" 
				position="0 0 0" rotation="-90 0 0"></a-entity>
		</a-entity>

		<!-- ========== BOOKCASE (MOD√àLE 3D) ========== -->
		<a-entity id="bookcase" position="-0.5 0 -2.5" rotation="0 -90 0" bookshelf-spawner="baseInterval: 2000; maxBooks: 12" static-body="shape: box; offset: -0.3 1.2 0.6; halfExtents: 1.2 1.2 0.3">
			<a-gltf-model src="./bookcase.glb" 
				shadow="cast: true; receive: true"
				scale="1 1 1" 
				position="-0.3 0 0.6">
			</a-gltf-model>
		</a-entity>

		<!-- ========== CERCLE CENTRAL (STOP TIME) ========== -->
		<a-entity id="zone-center" position="0 0.01 0" 
			time-zone="mode: stop; radius: 0.55; lightSpeed: 9000; needleSpeed: 6000">
			
			<!-- Anneau dor√© avec texture m√©tal -->
			<a-ring radius-inner="0.42" radius-outer="0.55" rotation="-90 0 0" 
				material="src: #metal-texture; color: #d9b066; opacity: 0.9; metalness: 0.4; roughness: 0.55"></a-ring>
			<a-ring radius-inner="0.18" radius-outer="0.26" rotation="-90 0 0" 
				material="src: #metal-texture; color: #d9b066; opacity: 0.6; metalness: 0.4; roughness: 0.55"></a-ring>
			
			<!-- Aiguille des minutes (longue, rapide) -->
			<a-entity id="needle-minute-center" position="0 0.03 0" rotation="0 0 0">
				<a-box width="0.40" height="0.015" depth="0.020" position="0.17 0 0" 
					material="src: #metal-texture; color: #d9b066; metalness: 0.4; roughness: 0.55"></a-box>
			</a-entity>
			
			<!-- Aiguille des heures (courte, lente) -->
			<a-entity id="needle-hour-center" position="0 0.05 0" rotation="0 90 0">
				<a-box width="0.28" height="0.020" depth="0.025" position="0.10 0 0" 
					material="src: #metal-texture; color: #c9a050; metalness: 0.4; roughness: 0.55"></a-box>
			</a-entity>
		</a-entity>

		<!-- Lumi√®re centrale -->
		<a-entity id="light-center" position="0 1.2 0">
			<a-entity light="type: spot; color: #ffd080; intensity: 0; angle: 45; penumbra: 0.5; castShadow: true" 
				position="0 0 0" rotation="-90 0 0"></a-entity>
		</a-entity>

		<!-- Cam√©ra avec limites -->
		<a-entity id="rig" position="0 0 1.5" boundary-limit vr-controller-movement="speed: 3.0; rotationSpeed: 45">
			<a-camera wasd-controls="acceleration: 8" look-controls position="0 1.8 0">
				<a-cursor color="#d9b066" fuse="false" raycaster="objects: .clickable-fallen-book, .pushable-book"></a-cursor>
			</a-camera>
			
			<!-- Contr√¥leur VR gauche -->
			<a-entity id="left-controller" 
				oculus-touch-controls="hand: left" 
				vive-controls="hand: left"
				windows-motion-controls="hand: left">
			</a-entity>
			
			<!-- Contr√¥leur VR droit -->
			<a-entity id="right-controller" 
				oculus-touch-controls="hand: right" 
				vive-controls="hand: right"
				windows-motion-controls="hand: right"
				raycaster="objects: .clickable-fallen-book, .pushable-book; showLine: false">
			</a-entity>
		</a-entity>
	</a-scene>
</body>
</html>
